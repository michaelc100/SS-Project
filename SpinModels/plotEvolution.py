#!/usr/bin/env python
import sys
import numpy as np
import matplotlib.pyplot as plt
import re
import os
from scipy.optimize import curve_fit

"""
Script to retrieve info about mc simulation of random graphs from graph evolution
Then calculates relevant info and produces various plots given these .txt files
"""

#needed to retrieve info from .txt files generated by graphEvolution.cpp
def extractInfo(filePath):
	
	temps = []
	means = []
	variance = []
	stderr = []
	jkerr = []
	with open(filePath, 'r') as f:
		count = 0
		for line in f:
			if line == "---\n":
				count += 1
			elif count == 0:
				temps.append(float(line))
			elif count > 0 and (line.split()[0] == "Mean"):
				means.append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Standard"):
				stderr.append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Variance:"):
				variance.append(float(re.findall(r"(-?\d*\.?\d+?e?-?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Jack"):
				jkerr.append(float(re.findall(r"(-?\d*\.?\d+?e?-?\d+)", line)[0]))
	
	suscept = [0]*len(variance)
	for i, var in enumerate(variance):
		suscept[i] = var/temps[i]

	return temps, means, variance, stderr, suscept, jkerr

def criticalTemp(filePath):
	t, m, v, st, su, jk = extractInfo(filePath)
	return t[np.argmax(su)]

#find associated error with log of variable with error
def logError(mag, magerror):
	logerrors = np.zeros(len(mag))
	for i, m in enumerate(mag):
		logerrors[i] = magerror[i]/m
	return logerrors

#needed for fitting curve
def func_linear(x, m, c):
	return c + m*x

t1, m1, v1, st1, su1, jk1 = extractInfo(sys.argv[1])
tc1 = criticalTemp(sys.argv[1])

plt.errorbar(t1, m1, yerr = st1, fmt = 'bo')
plt.plot(tc1, m1[t1.index(tc1)], 'r^', label = "Critical Temp")
plt.xlabel('Temperature')
plt.ylabel('Mean Magnetisation')
plt.title('Phase change of random graph with connectivity of 4, |V|=1000')
plt.legend()
plt.show()

plt.errorbar(t1, su1, yerr = jk1, fmt = 'bo')
plt.xlabel('Temperature')
plt.ylabel('Magnetic Susceptibility')
#plt.legend()
plt.show()

#remove critical temp for analysis to avoid log(0) errors
t1.remove(tc1)
m1.pop(np.argmax(su1))

log_t1 = np.log(np.absolute(np.array(t1) - tc1))
logm1 = np.log(m1)

popt_before, pcov_before = curve_fit(func_linear, logm1[:np.argmax(su1)], log_t1[:np.argmax(su1)])
perr_before = np.sqrt(np.diag(pcov_before))

popt_after, pcov_after = curve_fit(func_linear, logm1[np.argmax(su1):], log_t1[np.argmax(su1):])
perr_after = np.sqrt(np.diag(pcov_after))

plt.plot(logm1[np.argmax(su1):], popt_after[1] +logm1[np.argmax(su1):]*popt_after[0], 'r-', label = "Slope = {0}".format(popt_after[0]))
plt.plot(logm1[:np.argmax(su1)], popt_before[1] +logm1[:np.argmax(su1)]*popt_before[0], 'g-', label = "Slope = {0}".format(popt_before[0]))
plt.errorbar(logm1, log_t1, xerr = logError(m1, st1), fmt = 'bo')
plt.legend(loc = 'best')
plt.ylabel('ln(T-T_{c})')
plt.xlabel('ln(M(T))')
plt.title('log-log plot to determine critical parameter of phase change')
plt.show()

#percentage error calculated below
print "First estimate for critical param: {0} pm {1}".format(1/popt_before[0], (perr_before[0]/popt_before[0])*(1/popt_before[0]))  
print "Second estimate for critical param: {0} pm {1}".format(1/popt_after[0], (perr_after[0]/popt_after[0])*(1/popt_after[0]))

"""
#alternative fitting method perhaps
mpos, _ = np.polyfit(logm1[np.argmax(su1):], log_t1[np.argmax(su1):], 1)
mneg, _ = np.polyfit(logm1[:np.argmax(su1)], log_t1[:np.argmax(su1)], 1)

print 1/mpos
print 1/mneg
print logError(m1, st1)
"""

