#!/usr/bin/env python
import sys
import numpy as np
import matplotlib.pyplot as plt
import re
import os
from scipy.optimize import curve_fit

"""
Script to retrieve info about mc simulation of random graphs from graph evolution
Then calculates relevant info and produces various plots given these .txt files
"""

#needed to retrieve info from .txt files generated by graphEvolution.cpp
def extractInfo(filePath):
	mags = [] #raw mag values at each snapshot
	temps = []
	means = []
	variance = []
	stderr = []
	jkerr = []
	with open(filePath, 'r') as f:
		count = -1
		for line in f:
			if line.split()[0] == 'Info:':
				count += 1
			elif line == "---\n":
				mags.append([])
				count += 1
			elif count == 0:
				temps.append(float(line))
			elif count > 0 and (line.split()[0] == "Mag:"):
				mags[count - 1].append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Mean"):
				means.append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Standard"):
				stderr.append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Variance:"):
				variance.append(float(re.findall(r"(-?\d*\.?\d+?e?-?\d+)", line)[0]))
			elif count > 0 and (line.split()[0] == "Jack"):
				jkerr.append(float(re.findall(r"(-?\d*\.?\d+?e?-?\d+)", line)[0]))
	
	suscept = [0]*len(variance)
	for i, var in enumerate(variance):
		suscept[i] = var/temps[i]
	
	mags = mags[:-1] #remove last element which is just empty list formed bc of '---\n' at end of .txt file

	return temps, means, variance, stderr, suscept, jkerr, mags

def spinspin(filePath, compares):
	t, m, v, st, su, jk, ma = extractInfo(filePath)
	spinspin = [[list() for _ in range(0, compares)] for temp in range(0, len(t))]
	errors = [[list() for _ in range(0, compares)] for temp in range(0, len(t))]
	with open(filePath, 'r') as f:
		count = -1
		for line in f:
			if line.split()[0] == 'Info:':
				count += 1
			elif line == "---\n":
				count += 1
			if (line.split()[0] == "Spin-Spin"):
				spinspin[count-1][int(line.split()[-1])-1].append(float(re.findall(r"(-?\d*\.?\d+)", line)[0]))
				errors[count-1][int(line.split()[-1])-1].append(float(re.findall(r"(-?\d*\.?\d+)", line)[2]))
	for i, t in enumerate(spinspin):
		spinspin[i] = [spin[0] for spin in t]
	for i, t in enumerate(errors):
		errors[i] = [error[0] for error in t]
	return spinspin, errors

def criticalTemp(filePath):
	t, m, v, st, su, jk, ma = extractInfo(filePath)
	return t[np.argmax(su)]

#find associated error with log of variable with error
def logError(mag, magerror):
	logerrors = np.zeros(len(mag))
	for i, m in enumerate(mag):
		logerrors[i] = magerror[i]/m
	return logerrors

#needed for fitting curve
def func_linear(x, m, c):
	return c + m*x

def correlation_func_fit(r, A, xi, d):
	return A*((r)**(-(d-1)/2.0))*(np.exp(-r/xi))

def tc_correlation_fit(r, A, eta):
	return A*(r**(-(eta)))

def quadrature(values):
	quad = 0.0
	for val in values:
		quad += val**2
	return np.sqrt(quad)

def binderCumulant(mag_values): #calculate 4th order binder cumulant for mag values at a given temperature
	m4 = np.mean(np.array(mag_values)**4)
	m2 = np.mean(np.array(mag_values)**2)
	return 1.0 - float(m4/(3*m2**2))

def pairwiseAvg(array):  #very much advise having array of length 2**n
	pwavg_array = np.zeros(len(array)/2)
	j = 0
	i = 0
	while i < len(array):
		pwavg_array[j] = (array[i] + array[i+1])/2.0
		i += 2
		j += 1
	return pwavg_array

#for detecting auto-correlation stuff
def binAnalysis(magnetisation, order):
	magnetisation = np.array(magnetisation)
	n = len(magnetisation)
	var_bins = np.zeros(order)
	mag_bins = np.zeros(order)
	std_bins = np.zeros(order)
	for i in range(0, order):
		if i == 0:
			mag_bins[i] = np.mean(magnetisation)
			var_bins[i] = np.var(magnetisation, ddof = 1)
			std_bins[i] = np.sqrt(var_bins[i])/np.sqrt(float(len(magnetisation)))
		else:
			magnetisation = pairwiseAvg(magnetisation)
			mag_bins[i] = np.mean(magnetisation)
			var_bins[i] = np.var(magnetisation, ddof = 1)
			std_bins[i] = np.sqrt(var_bins[i])/np.sqrt(float(len(magnetisation)))
	
	return mag_bins, var_bins, std_bins

def jackKnife(data, f):
	#perform jackknife analysis of data set, f observable, returns one standard error
	data = np.array(data)
	n = len(data)
	base = f(data)
	sum_sterr = 0.0
	for i, dataPoint in enumerate(data):
		jackdata = np.delete(data, data[i])
		sum_sterr += (base - f(jackdata))**2
	return np.sqrt(((n-1)/n)*sum_sterr)


